from __future__ import annotations
# --- Relative distance engine ---
from relative_distance import PersonLocation, rank_drivers

# /opt/bumala_riders/bumala_riders_ussd.py



# USSD display limits
MAX_LIST = 10

# === LANDMARK HELPERS ===
def save_landmark(phone: str, name: str, description: str):
    import sqlite3
    db = sqlite3.connect(DB_PATH)
    cur = db.cursor()
    cur.execute(
        "INSERT INTO landmarks (phone, name, description) VALUES (?, ?, ?)",
        (phone, name, description)
    )
    db.commit()
    db.close()


import os
import re
import sqlite3
from dataclasses import dataclass
from typing import List, Tuple, Optional


# --- villages (used by businesses menu) ---
# pick_from_list() expects (key,label) pairs
VILLAGES = [
    ("1", "Bumala"),
    ("2", "Butula"),
    ("3", "Busia"),
]
# ------------------------------------------

# === CHALLENGE_SCHEMA_V1 ===
import re

# Onboarding gate (role -> area -> landmark)
import onboarding

# ============================================================
# User prefs (role) - stored per phone
# ============================================================
def ensure_user_prefs(conn: sqlite3.Connection) -> None:
    cur = conn.cursor()
    cur.execute(
        "CREATE TABLE IF NOT EXISTS user_prefs ("
        " phone TEXT PRIMARY KEY,"
        " role  TEXT NOT NULL DEFAULT 'customer',"
        " updated_at TEXT NOT NULL DEFAULT (datetime('now'))"
        ");"
    )
    conn.commit()

def get_user_role(phone: str) -> str:
    try:
        conn = db()
        ensure_user_prefs(conn)
        cur = conn.cursor()
        cur.execute("SELECT role FROM user_prefs WHERE phone = ? LIMIT 1;", (phone,))
        row = cur.fetchone()
        if row is None:
            return 'customer'
        # sqlite Row or tuple
        try:
            return (row['role'] or 'customer')
        except Exception:
            return (row[0] or 'customer')
    except Exception:
        return 'customer'
    finally:
        try:
            conn.close()
        except Exception:
            pass

def set_user_role(phone: str, role: str) -> None:
    role = (role or 'customer').strip().lower()
    if role not in ('customer', 'provider'):
        role = 'customer'
    conn = db()
    ensure_user_prefs(conn)
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO user_prefs(phone, role, updated_at) VALUES (?, ?, datetime('now')) "
        "ON CONFLICT(phone) DO UPDATE SET role=excluded.role, updated_at=datetime('now');",
        (phone, role),
    )
    conn.commit()
    conn.close()

def provider_home_menu() -> str:
    lines = [
        'CON Service Provider',
        '1. My profile (register/update)',
        '2. My services (add/remove)',
        '3. Update my landmark',
        '4. Incoming requests',
        '9. Switch role',
        '0. Exit',
    ]
    return '\n'.join(lines)

def handle_role_switch(parts: list[str], phone: str) -> str:
    # parts[0] == '9'
    if len(parts) == 1:
        return '\n'.join([
            'CON Angelopp',
            '1. I am a Customer',
            '2. I am a Service Provider',
            '0. Exit',
        ])
    choice = (parts[1] if len(parts) >= 2 else '').strip()
    if choice == '1':
        set_user_role(phone, 'customer')
        return 'CON Role set ✓\nYou are now: Customer\n0. Back'
    if choice == '2':
        set_user_role(phone, 'provider')
        return 'CON Role set ✓\nYou are now: Service Provider\n0. Back'
    if choice == '0':
        return 'END Bye'
    return 'CON Invalid option.\n0. Back'

# --- UI icons (safe defaults) ---
ICON_GO = '->'
ICON_STAR = '*'
ICON_CHECK = 'OK'
ICON_DONE = "OK"


def _clean_text(s: str, max_len: int) -> str:
    s = (s or "").strip()
    s = re.sub(r"\s+", " ", s)
    s = re.sub(r"[^0-9A-Za-z \-,'/().]", "", s)
    return s[:max_len].strip()

def ensure_challenge_schema():
    conn = db()
    cur = conn.cursor()

    cur.execute("""
    CREATE TABLE IF NOT EXISTS daily_claims (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        phone TEXT NOT NULL,
        claim_date TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        UNIQUE(phone, claim_date)
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS landmarks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        phone TEXT NOT NULL,
        village TEXT NOT NULL DEFAULT 'Bumala',
        name TEXT NOT NULL,
        description TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS points_ledger (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        phone TEXT NOT NULL,
        pts INTEGER NOT NULL,
        reason TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
    """)

    conn.commit()
    conn.close()

def _add_points(phone: str, pts: int, reason: str):
    conn = db()
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO points_ledger(phone, pts, reason) VALUES (?, ?, ?)",
        (phone, int(pts), (reason or "")[:40])
    )
    conn.commit()
    conn.close()

def _mark_claim_today(phone: str) -> bool:
    conn = db()
    cur = conn.cursor()
    try:
        cur.execute(
            "INSERT INTO daily_claims(phone, claim_date) VALUES (?, date('now'))",
            (phone,)
        )
        conn.commit()
        ok = True
    except Exception:
        ok = False
    conn.close()
    return ok

def _added_landmark_today(phone: str) -> bool:
    """Return True if this phone already added a landmark today.
    Uses absolute DB path to avoid 'wrong working directory' surprises.
    """
    import sqlite3
    db = sqlite3.connect(DB_PATH)
    try:
        cur = db.cursor()
        cur.execute(
            """
            SELECT 1
            FROM landmarks
            WHERE phone = ?
              AND date(created_at) = date('now')
            LIMIT 1
            """,
            (phone,)
        )
        return cur.fetchone() is not None
    finally:
        db.close()

# --- constants (auto-added) ---
DB_PATH = '/opt/angelopp/data/bumala.db'
# ------------------------------


def db() -> sqlite3.Connection:
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def ensure_schema() -> None:
    conn = db()
    cur = conn.cursor()

    # Riders directory
    cur.execute("""
    CREATE TABLE IF NOT EXISTS riders (
        phone TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        village TEXT NOT NULL,
        rider_type TEXT NOT NULL,
        sacco TEXT DEFAULT '',
        location TEXT DEFAULT '',
        created_at TEXT DEFAULT (datetime('now')),
        updated_at TEXT DEFAULT (datetime('now'))
    )
    """)

    # Customers (optional)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS customers (
        phone TEXT PRIMARY KEY,
        name TEXT DEFAULT '',
        village TEXT DEFAULT '',
        created_at TEXT DEFAULT (datetime('now')),
        updated_at TEXT DEFAULT (datetime('now'))
    )
    """)

    # Businesses directory (Yellow Pages)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS businesses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        owner_phone TEXT NOT NULL,
        name TEXT NOT NULL,
        category TEXT NOT NULL,
        village TEXT NOT NULL,
        location TEXT DEFAULT '',
        created_at TEXT DEFAULT (datetime('now')),
        updated_at TEXT DEFAULT (datetime('now'))
    )
    """)

    cur.execute("CREATE INDEX IF NOT EXISTS idx_businesses_village ON businesses(village)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_businesses_category ON businesses(category)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_businesses_owner ON businesses(owner_phone)")

    # Landmarks (community map)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS landmarks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        village TEXT NOT NULL,
        name TEXT NOT NULL,
        added_by TEXT NOT NULL,
        created_at TEXT DEFAULT (datetime('now'))
    )
    """)
    # Landmarks indexes
    cur.execute("CREATE INDEX IF NOT EXISTS idx_landmarks_village ON landmarks(village)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_landmarks_added_by ON landmarks(added_by)")


    # =========================================================
    # Channels (community micro-radio) — MVP
    # =========================================================
    cur.execute("""
    CREATE TABLE IF NOT EXISTS channels (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        owner_phone TEXT NOT NULL,
        name TEXT NOT NULL,
        category TEXT NOT NULL DEFAULT 'Community',
        is_active INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
    """)
    cur.execute("CREATE INDEX IF NOT EXISTS idx_channels_owner ON channels(owner_phone)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_channels_category ON channels(category)")

    cur.execute("""
    CREATE TABLE IF NOT EXISTS channel_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        channel_id INTEGER NOT NULL,
        text TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        FOREIGN KEY(channel_id) REFERENCES channels(id)
    )
    """)
    cur.execute("CREATE INDEX IF NOT EXISTS idx_channel_messages_channel ON channel_messages(channel_id)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_channel_messages_created ON channel_messages(created_at)")


    # -----------------------------
    # Channels (text-only micro radio)
    # -----------------------------
    cur.execute("""
    CREATE TABLE IF NOT EXISTS channels (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        owner_phone TEXT NOT NULL,
        name TEXT NOT NULL,
        category TEXT NOT NULL DEFAULT 'Community',
        is_active INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
    """)

    cur.execute("CREATE INDEX IF NOT EXISTS idx_channels_owner_active ON channels(owner_phone, is_active)")

    cur.execute("""
    CREATE TABLE IF NOT EXISTS channel_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        channel_id INTEGER NOT NULL,
        sender_phone TEXT NOT NULL,
        message TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        FOREIGN KEY(channel_id) REFERENCES channels(id)
    )
    """)

    cur.execute("CREATE INDEX IF NOT EXISTS idx_channel_messages_channel ON channel_messages(channel_id, created_at)")


    # Points / Challenge rewards
    cur.execute("""
    CREATE TABLE IF NOT EXISTS points (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        phone TEXT NOT NULL,
        reason TEXT NOT NULL,
        pts INTEGER NOT NULL,
        created_at TEXT DEFAULT (datetime('now'))
    )
    """)
    cur.execute("CREATE INDEX IF NOT EXISTS idx_points_phone ON points(phone)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_points_created_at ON points(created_at)")

    # Callback requests (future AT voice callback / or manual SACCO-assisted)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS callback_requests (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,
        customer_phone TEXT NOT NULL,
        target_phone TEXT NOT NULL,
        target_kind TEXT NOT NULL,  -- 'rider' or 'business'
        village TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'NEW',
        created_at TEXT DEFAULT (datetime('now'))
    )
    """)
    cur.execute("CREATE INDEX IF NOT EXISTS idx_callbacks_status ON callback_requests(status)")

    conn.commit()
    conn.close()


# =========================
# USSD UTIL
# =========================

def digits_only(s: str) -> str:
    return re.sub(r"\D+", "", s or "")


def normalize_phone(phone: str) -> str:
    # Accept "+2547..." etc; store digits with leading +
    p = phone.strip()
    if p.startswith("+"):
        return "+" + digits_only(p)
    d = digits_only(p)
    if d.startswith("254"):
        return "+" + d
    if d.startswith("0") and len(d) >= 10:
        return "+254" + d[1:]
    # fallback
    return "+" + d
def parse_text(text: str):
    """Split Africa's Talking USSD text into tokens.

    IMPORTANT: do NOT filter tokens by numeric range.
    We must preserve options like '8' and free-text tokens (names/messages).
    """
    raw = (text or "").strip()
    if not raw:
        return []
    return [p.strip() for p in raw.split("*") if p.strip() != ""]

